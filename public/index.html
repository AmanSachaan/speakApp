<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stranger Connect Voice Chat</title>
    <style>
        body { font-family: sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #f4f4f9; }
        h1 { color: #333; text-align: center; }
        #status { font-weight: bold; margin-bottom: 15px; padding: 10px; border: 1px solid #ccc; background-color: #e0f7fa; border-radius: 4px; text-align: center; font-size: 1.2em; }
        .controls { text-align: center; margin-top: 20px; }
        .controls button { padding: 12px 20px; margin: 0 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 1em; font-weight: bold; transition: background-color 0.3s; }
        #connectButton { background-color: #28a745; color: white; }
        #connectButton:hover { background-color: #218838; }
        #disconnectButton { background-color: #dc3545; color: white; }
        #disconnectButton:disabled { background-color: #f8d7da; color: #721c24; cursor: not-allowed; }
        #localAudio, #remoteAudio { display: none; } /* Voice chat doesn't need video elements */
        #log { height: 150px; border: 1px solid #ddd; overflow-y: scroll; padding: 10px; margin-top: 15px; background-color: white; border-radius: 4px; font-size: 0.8em; }
        .log-message { margin: 2px 0; color: #6c757d; }
    </style>
</head>
<body>

    <h1>Stranger Voice Connect üó£Ô∏è</h1>

    <div id="status">Connecting...</div>

    <audio id="remoteAudio" autoplay></audio> 

    <div class="controls">
        <button onclick="connectStranger()" id="connectButton">Connect</button>
        <button onclick="disconnectStranger()" id="disconnectButton" disabled>Disconnect</button>
    </div>

    <h2>Activity Log</h2>
    <div id="log"></div>

    <script>
        // üîë RENDER FIX: Dynamically set the protocol (wss for production/Render, ws for local)
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const host = window.location.host;
        const websocketUrl = `${protocol}://${host}`; 
        
        let socket = null;
        let peerConnection = null;
        let localStream = null;

        const statusElement = document.getElementById('status');
        const logElement = document.getElementById('log');
        const disconnectButton = document.getElementById('disconnectButton');
        const connectButton = document.getElementById('connectButton');
        const remoteAudio = document.getElementById('remoteAudio');

        const ICE_SERVERS = {
            iceServers: [
                // Free STUN server to help discover public IP addresses
                { urls: 'stun:stun.l.google.com:19302' }, 
            ]
        };

        function logMessage(text, className = 'log-message') {
            const msgDiv = document.createElement('div');
            msgDiv.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            msgDiv.classList.add(className);
            logElement.appendChild(msgDiv);
            logElement.scrollTop = logElement.scrollHeight;
        }

        function setControls(isPaired) {
            disconnectButton.disabled = !isPaired;
            connectButton.textContent = isPaired ? 'Find New Stranger' : 'Connect';
            connectButton.disabled = false; // Always allow reconnection
        }

        // --- WebRTC Logic ---

        async function startLocalMedia() {
            try {
                // Request microphone access (audio only)
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                logMessage("Microphone access granted.");
                
                // You could optionally attach the stream to a local hidden video element for debugging
                // document.getElementById('localAudio').srcObject = localStream;
                return true;
            } catch (e) {
                logMessage(`Error getting media: ${e.name}. Please allow microphone access.`, 'log-error');
                statusElement.textContent = "Error: Microphone Required";
                return false;
            }
        }

        function createPeerConnection(isInitiator) {
            if (peerConnection) closePeerConnection();
            
            peerConnection = new RTCPeerConnection(ICE_SERVERS);

            // 1. Add the local stream (audio track) to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            logMessage("Local audio track added to peer connection.");

            // 2. Handle remote stream (stranger's voice)
            peerConnection.ontrack = (event) => {
                logMessage("Received remote audio track.");
                if (remoteAudio.srcObject !== event.streams[0]) {
                    remoteAudio.srcObject = event.streams[0];
                    remoteAudio.play().catch(e => logMessage(`Error playing audio: ${e}`, 'log-error'));
                }
            };

            // 3. Handle ICE Candidates (network information)
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send ICE Candidate to the stranger via the signaling server
                    socket.send(JSON.stringify({
                        type: 'SIGNAL',
                        signal: { candidate: event.candidate }
                    }));
                }
            };
            
            // 4. If the initiator, create the SDP Offer immediately
            if (isInitiator) {
                peerConnection.onnegotiationneeded = async () => {
                    try {
                        const offer = await peerConnection.createOffer();
                        await peerConnection.setLocalDescription(offer);
                        // Send the SDP Offer to the stranger via the signaling server
                        socket.send(JSON.stringify({
                            type: 'SIGNAL',
                            signal: { sdp: peerConnection.localDescription }
                        }));
                        logMessage("Sent WebRTC Offer to stranger.");
                    } catch (e) {
                        logMessage(`Error creating offer: ${e}`, 'log-error');
                    }
                };
            }
            
            logMessage("RTCPeerConnection created successfully.");
        }

        async function handleSignal(signal) {
            if (!peerConnection) return;

            if (signal.sdp) {
                // Received an Offer or an Answer
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp));
                    logMessage(`Received WebRTC ${signal.sdp.type.toUpperCase()}.`);

                    if (signal.sdp.type === 'offer') {
                        // If it's an Offer, create and send an Answer
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        // Send the SDP Answer to the initiator
                        socket.send(JSON.stringify({
                            type: 'SIGNAL',
                            signal: { sdp: peerConnection.localDescription }
                        }));
                        logMessage("Sent WebRTC Answer to initiator.");
                    }
                } catch (e) {
                    logMessage(`Error handling SDP: ${e}`, 'log-error');
                }

            } else if (signal.candidate) {
                // Received an ICE Candidate
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                    logMessage("Added ICE Candidate.");
                } catch (e) {
                    logMessage(`Error adding ICE candidate: ${e}`, 'log-error');
                }
            }
        }
        
        function closePeerConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
                logMessage("WebRTC connection closed.");
            }
            if (remoteAudio.srcObject) {
                remoteAudio.srcObject.getTracks().forEach(track => track.stop());
                remoteAudio.srcObject = null;
            }
        }
        
        // --- WebSocket Logic ---

        function connectStranger() {
            if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
                // Send explicit CONNECT signal to tell the server to re-queue/re-pair
                socket.send(JSON.stringify({ type: 'CONNECT' }));
                statusElement.textContent = 'Connecting...';
                logMessage("Requesting new pairing from server...", 'log-message');
                setControls(false);
                closePeerConnection(); // Close old peer connection
                return;
            }
            
            statusElement.textContent = 'Connecting to server...';
            logMessage("Starting WebSocket connection...", 'log-message');
            setControls(false);

            // 1. Establish WebSocket connection
            socket = new WebSocket(websocketUrl); 

            socket.onopen = async () => {
                logMessage("Connection to server established. Waiting for a match.", 'log-message');
                await startLocalMedia(); // Request microphone on successful server connection
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);

                switch (data.type) {
                    case 'STATUS':
                        statusElement.textContent = data.message;
                        logMessage(`[STATUS] ${data.message}`);
                        break;
                        
                    case 'PAIR_FOUND':
                        statusElement.textContent = 'Voice chat connected! Say hello.';
                        logMessage(data.message);
                        setControls(true);
                        // 2. Pair found, now start the WebRTC process
                        if (localStream) {
                            createPeerConnection(data.initiator);
                        } else {
                             logMessage("Cannot start WebRTC: Microphone access failed.", 'log-error');
                        }
                        break;

                    case 'SIGNAL':
                        // 3. Handle WebRTC signaling data
                        handleSignal(data.signal);
                        break;
                        
                    case 'DISCONNECTED':
                        // The partner initiated the disconnection
                        statusElement.textContent = data.message;
                        logMessage(`[SYSTEM] ${data.message} Looking for a new partner...`);
                        setControls(false); 
                        closePeerConnection(); // Close the WebRTC connection
                        // The server has already re-queued us
                        break;
                }
            };

            socket.onclose = () => {
                statusElement.textContent = 'Disconnected from server.';
                logMessage("[SYSTEM] Server connection closed.", 'log-message');
                setControls(false);
                closePeerConnection(); 
            };

            socket.onerror = (error) => {
                console.error("WebSocket Error:", error);
                statusElement.textContent = 'Connection Error. See console.';
                logMessage("[ERROR] Could not connect. Check console.", 'log-error');
                closePeerConnection(); 
            };
        }

        function disconnectStranger() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                // Send a signal to the server to disconnect from the current partner
                socket.send(JSON.stringify({ type: 'DISCONNECT' }));
                statusElement.textContent = 'You disconnected. Looking for a new stranger...';
                logMessage("[SYSTEM] Disconnected from current stranger. Waiting for a new match.");
                setControls(false);
                closePeerConnection(); // Immediately close WebRTC connection
                // Server will automatically re-queue
            }
        }
        
        // Initial connection attempt on page load
        connectStranger();
    </script>
</body>
</html>