<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stranger Voice Connect (React UI)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }
        #root {
            width: 100%;
            max-width: 450px;
        }
        .app-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 25px;
            text-align: center;
        }
        h1 {
            color: #1c2b36;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        .status-bar {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }
        .status-default { background-color: #e0f7fa; color: #007bff; }
        .status-waiting { background-color: #fff8e1; color: #ffa000; }
        .status-connected { background-color: #e8f5e9; color: #388e3c; }

        .indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 1.5s infinite; 
        }
        .indicator.waiting { background-color: #ffa000; }
        .indicator.connected { background-color: #388e3c; }

        .controls {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.2s;
            flex: 1;
            margin: 0 5px;
        }
        .btn-connect { background-color: #007bff; color: white; }
        .btn-connect:hover { background-color: #0056b3; }
        .btn-connect:disabled { background-color: #adb5bd; cursor: not-allowed; }
        .btn-disconnect { background-color: #dc3545; color: white; }
        .btn-disconnect:hover { background-color: #c82333; }
        .btn-disconnect:disabled { opacity: 0.6; cursor: not-allowed; }
        
        /* New Tip Box Styling */
        .tip-toggle {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
            cursor: pointer;
            color: #6c757d;
            font-size: 1em;
            font-weight: 500;
            transition: color 0.2s;
        }
        .tip-toggle:hover {
            color: #007bff;
        }
        .tip-icon {
            font-size: 1.5em; /* Larger size for the bulb icon */
            margin-right: 5px;
        }

        .tip-cards-container {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, padding 0.4s ease-in-out;
        }
        .tip-cards-container.visible {
            max-height: 200px; /* Large enough to show both cards */
            padding-bottom: 15px;
        }
        .tip-card {
            background: #f7f9fc;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            font-size: 0.9em;
            text-align: left;
            border-left: 3px solid #007bff;
            opacity: 0; /* Start hidden */
            transform: translateY(10px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        .tip-card.show {
            opacity: 1;
            transform: translateY(0);
        }
        .tip-card strong {
            display: block;
            margin-bottom: 3px;
            color: #333;
            font-size: 1em;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(56, 142, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(56, 142, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(56, 142, 60, 0); }
        }
        
    </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // WebRTC Configuration: Use Google's STUN server for NAT traversal
        const rtcConfig = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const host = window.location.host;
        const websocketUrl = `${protocol}://${host}`; 

        // ----------------------------------------------------------------
        // Main App Component
        // ----------------------------------------------------------------

        const VoiceConnectApp = () => {
            const [status, setStatus] = useState("Welcome! Click Connect to find a stranger.");
            const [isPaired, setIsPaired] = useState(false);
            const [isConnecting, setIsConnecting] = useState(false);
            const [showTips, setShowTips] = useState(false); // New state for tips visibility
            
            const socketRef = useRef(null);
            const peerConnectionRef = useRef(null);
            const localStreamRef = useRef(null);
            const remoteAudioRef = useRef(null);

            // Output logs to console only
            const logMessage = useCallback((text, isError = false) => {
                if (isError) {
                    console.error(`[${new Date().toLocaleTimeString()}] [ERROR] ${text}`);
                } else {
                    console.log(`[${new Date().toLocaleTimeString()}] ${text}`);
                }
            }, []);

            const setControls = useCallback((pairedStatus, connectingStatus, statusText) => {
                setIsPaired(pairedStatus);
                setIsConnecting(connectingStatus);
                if (statusText) setStatus(statusText);
            }, []);

            // ----------------------------------------------------------------
            // WebRTC Logic (Unchanged from previous functional version)
            // ----------------------------------------------------------------

            const closeWebRTC = useCallback(() => {
                if (peerConnectionRef.current) {
                    peerConnectionRef.current.close();
                    peerConnectionRef.current = null;
                    logMessage('WebRTC connection closed.');
                }
                if (localStreamRef.current) {
                    localStreamRef.current.getTracks().forEach(track => track.stop());
                    localStreamRef.current = null;
                }
                if (remoteAudioRef.current) {
                    remoteAudioRef.current.srcObject = null;
                }
            }, [logMessage]);

            const startLocalStream = useCallback(async () => {
                if (localStreamRef.current) return true;

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    localStreamRef.current = stream;
                    logMessage('Microphone access granted. Ready to call.');
                    return true;
                } catch (err) {
                    logMessage('ERROR: Could not get microphone access. Check permissions.', true);
                    setControls(false, false, 'Voice Error: Microphone required.');
                    return false;
                }
            }, [logMessage, setControls]);

            const createPeerConnection = useCallback((isCaller) => {
                peerConnectionRef.current = new RTCPeerConnection(rtcConfig);
                const pc = peerConnectionRef.current;
                const socket = socketRef.current;

                localStreamRef.current.getTracks().forEach(track => {
                    pc.addTrack(track, localStreamRef.current);
                });

                pc.ontrack = (event) => {
                    if (remoteAudioRef.current && remoteAudioRef.current.srcObject !== event.streams[0]) {
                        remoteAudioRef.current.srcObject = event.streams[0];
                        logMessage('Remote stream received! Voice connection established. 🗣️');
                    }
                };

                pc.onicecandidate = (event) => {
                    if (event.candidate && socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({
                            type: 'CANDIDATE',
                            candidate: event.candidate
                        }));
                    }
                };

                pc.oniceconnectionstatechange = () => {
                    logMessage(`ICE State: ${pc.iceConnectionState}`);
                    if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                         logMessage('ICE connection failed or disconnected. Trying to reconnect/close.', true);
                    }
                };

                if (isCaller) {
                    pc.onnegotiationneeded = async () => {
                        try {
                            const offer = await pc.createOffer();
                            await pc.setLocalDescription(offer);
                            socket.send(JSON.stringify({ type: 'OFFER', sdp: pc.localDescription }));
                            logMessage('WebRTC Offer sent.');
                        } catch (e) {
                            logMessage('Failed to create/send offer: ' + e, true);
                        }
                    };
                }
            }, [logMessage]);

            const handleOffer = useCallback(async (sdp) => {
                try {
                    if (!peerConnectionRef.current) {
                        createPeerConnection(false);
                    }
                    const pc = peerConnectionRef.current;
                    await pc.setRemoteDescription(sdp);
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    socketRef.current.send(JSON.stringify({ type: 'ANSWER', sdp: pc.localDescription }));
                    logMessage('WebRTC Answer sent.');
                } catch (e) {
                    logMessage('Failed to handle offer: ' + e, true);
                }
            }, [logMessage, createPeerConnection]);

            const handleAnswer = useCallback(async (sdp) => {
                try {
                    await peerConnectionRef.current.setRemoteDescription(sdp);
                    logMessage('WebRTC Answer received.');
                } catch (e) {
                    logMessage('Failed to handle answer: ' + e, true);
                }
            }, [logMessage]);

            const handleCandidate = useCallback(async (candidate) => {
                try {
                    if (!peerConnectionRef.current) {
                        logMessage('Ignoring late CANDIDATE: PeerConnection not established.');
                        return;
                    }
                    await peerConnectionRef.current.addIceCandidate(new RTCIceCandidate(candidate));
                    logMessage('ICE Candidate added.');
                } catch (e) {
                    logMessage('Failed to add ICE candidate: ' + e, true);
                }
            }, [logMessage]);


            // ----------------------------------------------------------------
            // WebSocket/Connection Handlers (Unchanged)
            // ----------------------------------------------------------------

            const connectStranger = useCallback(async () => {
                if (isConnecting) return;
                
                if (!await startLocalStream()) {
                    return; 
                }
                
                setControls(false, true, 'Connecting to server...');

                if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {
                    socketRef.current.send(JSON.stringify({ type: 'CONNECT' }));
                    setControls(false, true, 'Looking for a stranger...');
                    logMessage("Searching for a new stranger...");
                    return;
                }
                
                if (socketRef.current) socketRef.current.close(); 

                logMessage("Starting server connection...");
                socketRef.current = new WebSocket(websocketUrl); 
                const socket = socketRef.current;

                socket.onopen = () => {
                    logMessage("Connection to server established. Requesting match.");
                    socket.send(JSON.stringify({ type: 'CONNECT' }));
                };

                socket.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    
                    switch (data.type) {
                        case 'STATUS':
                            setStatus(data.message);
                            logMessage(`[STATUS] ${data.message}`);
                            if (data.message.includes('Connected')) {
                                logMessage('Paired! Setting up WebRTC...');
                            } else if (!data.message.includes('Waiting')) {
                                setControls(false, false); 
                            }
                            break;
                        
                        case 'START_CALL':
                            setControls(true, false, 'Connected! Starting voice call.'); 
                            logMessage('Starting WebRTC connection as Caller (sending OFFER).');
                            createPeerConnection(true); 
                            break;

                        case 'DISCONNECTED':
                            closeWebRTC();
                            setStatus(data.message);
                            logMessage("Partner disconnected. Click Connect to find a new match.");
                            setControls(false, false);
                            break;
                            
                        // WebRTC Signaling
                        case 'OFFER':
                            setControls(true, false, 'Connected! Starting voice call.');
                            logMessage('Offer received. Sending Answer.');
                            await handleOffer(data.sdp);
                            break;
                        case 'ANSWER':
                            await handleAnswer(data.sdp);
                            break;
                        case 'CANDIDATE':
                            await handleCandidate(data.candidate);
                            break;
                    }
                };

                socket.onclose = () => {
                    closeWebRTC();
                    setStatus('Disconnected from server.');
                    logMessage("Server connection closed. Click Connect to try again.", true);
                    setControls(false, false);
                };

                socket.onerror = (error) => {
                    console.error("WebSocket Error:", error);
                    closeWebRTC();
                    setStatus('Connection Error. See browser console.');
                    logMessage("ERROR: Could not connect to server.", true);
                    setControls(false, false);
                };
            }, [logMessage, setControls, startLocalStream, createPeerConnection, handleOffer, handleAnswer, handleCandidate, closeWebRTC, isConnecting]);

            const disconnectStranger = useCallback(() => {
                if (socketRef.current && isPaired) { 
                    socketRef.current.send(JSON.stringify({ type: 'DISCONNECT' }));
                    
                    closeWebRTC();
                    setStatus('You disconnected. Click Connect to find a new stranger.');
                    logMessage("Disconnected from current stranger.");
                    setControls(false, false); 
                }
            }, [closeWebRTC, isPaired, logMessage, setControls]);
            
            // Set initial state
            useEffect(() => {
                 setControls(false, false, "Welcome! Click Connect to find a stranger.");
            }, [setControls]);
            
            // State for tip cards to reveal them one by one
            const [tipCard1Visible, setTipCard1Visible] = useState(false);
            const [tipCard2Visible, setTipCard2Visible] = useState(false);

            useEffect(() => {
                let timer1, timer2;
                if (showTips) {
                    // Reveal first card immediately when showTips is true
                    setTipCard1Visible(true);
                    
                    // Reveal second card after a short delay
                    timer2 = setTimeout(() => {
                        setTipCard2Visible(true);
                    }, 200);
                } else {
                    // Hide cards immediately when showTips is false
                    setTipCard2Visible(false);
                    setTipCard1Visible(false);
                }
                
                return () => {
                    clearTimeout(timer1);
                    clearTimeout(timer2);
                };
            }, [showTips]);


            const getStatusClass = () => {
                if (isPaired) return 'status-connected';
                if (isConnecting) return 'status-waiting';
                return 'status-default';
            };

            return (
                <div className="app-card">
                    <h1>Stranger Voice Connect</h1>
                    
                    <div className={`status-bar ${getStatusClass()}`}>
                        {isPaired && <span className="indicator connected"></span>}
                        {status}
                    </div>

                    <div className="controls">
                        <button 
                            className="btn-connect"
                            onClick={connectStranger} 
                            disabled={isConnecting && !isPaired}
                        >
                            {isPaired ? 'Find New Stranger' : 'Connect'}
                        </button>
                        <button 
                            className="btn-disconnect"
                            onClick={disconnectStranger} 
                            disabled={!isPaired}
                        >
                            Disconnect
                        </button>
                    </div>

                    {/* Tip Toggle Icon */}
                    <div className="tip-toggle" onClick={() => setShowTips(!showTips)}>
                        <span className="tip-icon">💡</span> 
                        {showTips ? 'Hide Tips' : 'Connectivity Tips'}
                    </div>

                    {/* Tip Cards Container (Controlled by state) */}
                    <div className={`tip-cards-container ${showTips ? 'visible' : ''}`}>
                        <div className={`tip-card ${tipCard1Visible ? 'show' : ''}`} style={{ transitionDelay: '0s' }}>
                            <strong>Keep Browser Active</strong>
                            Do not minimize the browser to maintain a stable connection.
                        </div>
                        <div className={`tip-card ${tipCard2Visible ? 'show' : ''}`} style={{ transitionDelay: '0.1s' }}>
                            <strong>Avoid Screen Lock</strong>
                            Do not lock your screen, as this may pause network activity and cause a disconnect.
                        </div>
                    </div>
                    
                    {/* Audio elements are hidden and only used for streaming */}
                    <audio ref={remoteAudioRef} autoPlay></audio>
                    <audio id="localAudio" autoPlay muted style={{display: 'none'}}></audio>
                </div>
            );
        };

        ReactDOM.render(<VoiceConnectApp />, document.getElementById('root'));
    </script>
</body>
</html>